<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="nodejs metrics"/>
    <meta name="color-scheme" content="light dark"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css"/>
    <title>Nodejs Metrics</title>
    </head>
  <body>
    <header class="container">
      <nav>
        <ul>
          <li>
            <hgroup>
              <h1>Nodejs Metrics</h1>
              <p>Process load measuring for NodeJs</p>
            </hgroup>
          </li>
        </ul>
      </nav>
    </header>

    <aside class="container">
        <kbd><closed-shadow text="Waiting for connection"></closed-shadow></kbd>
    </aside>

    <nav aria-label="breadcrumb" class="container">
      <ul>
        <li><a href="#">Home</a></li>
        <li>Measures</li>
      </ul>
    </nav>

    <main class="container-fluid">
      <section class="grid">
        <article>
          <header><strong>Nodejs Version</strong></header>
          <metrics-card text="-" data-metric ="metadata.nodejs_version_info"></metrics-card>
        </article>
        <article>
          <header><strong>Uptime</strong></header>
          <metrics-card text="-" data-metric ="process_start_time_seconds"></metrics-card>
        </article>
        <article>
          <header><strong>Event loop utilized</strong></header>
          <metrics-card text="-" data-metric ="event_loop_utilized"></metrics-card> %
        </article>
        <article>
          <header><strong>Event loop delay</strong></header>
          <metrics-card text="-" data-metric ="event_loop_delay_milliseconds"></metrics-card> sec
        </article>
      </section>

      <section>
      </section>
    </main>

    <footer class="container">
      <hr/>
      <p>
        <strong>Nodejs metrics</strong> |
        <a class="secondary" href="https://github.com/stephen-shopopop/node-metrics" title="github" target="_blank">Github</a>
         - <small>Currently v1.0.0</small>
      </p>
      <cite>— Author: stephen</cite>
    </footer>
  </body>
  <script type="module">
//    import uplot from 'https://cdn.jsdelivr.net/npm/uplot@1.6.32/+esm'

    // console.log(uplot)

    /** Channel */
    const channel = Object.freeze({
      eventType : {
        onError: 'on-error',
        onReady: 'on-ready',
        onMessage: 'on-message'
      },
      publish: (eventName, metatdata = {}) => document.dispatchEvent(new CustomEvent(`events:${eventName}`, { detail: metatdata })),
      subscribe: (eventName, callback = () => {/***/}) => document.addEventListener(`events:${eventName}`, evt => callback(evt.detail))
    });

    /** Error handling */
    const errorHandler = (error, metadata = {}) => {
      console.error('%c %s %s %O', 'background: #E65842; font-weight: bold; color: white; padding: 2px 0px;', '⚠️', error, metadata);
    }

    /** Parses a JSON string safely */
    const safeJsonParse = (data, unsecure = false) => {
      try {
        return JSON.parse(data);
      } catch {
        if(!unsecure) throw new Error('Invalid JSON!');
        return data;
      }
    };


    /** Fetch Metrics for service NodeJs and disptach on apps UI */
    const fetchMetricsStream = (uri = '/metrics-stream') => {
      const evtSource = new EventSource(uri);

      evtSource.onerror = (e) => {
        channel.publish(channel.eventType.onError, new Error('An error occurred while attempting to connect'));

        evtSource.close();
      };

      evtSource.onmessage = (event) => {
        try {
          const json = safeJsonParse(event.data);

          channel.publish(channel.eventType.onMessage, {
            ...json?.payload,
            time: json?.ts ?? null
          });
        } catch (err) {
          channel.publish(channel.eventType.onError, err);

          evtSource.close();
        }
      };

      evtSource.onopen = (e) => channel.publish(channel.eventType.onReady, { message : 'The connection has been established' });
    }

    const humanDate = (date, locales = 'default-u-nu-latn') => {
      let dateObj;
      if (typeof date === 'string') dateObj = new Date(date);
      else dateObj = date;

      const options = { month: 'long', day: 'numeric',hour: 'numeric', minute: 'numeric', second: 'numeric' };

      const dateYear = dateObj.toLocaleString(locales, { year: 'numeric' });
      const dateMonth = dateObj.toLocaleString(locales, { month: 'numeric' });
      const dateDay = dateObj.toLocaleString(locales, { day: 'numeric' });
      const dateHour = dateObj.getHours();
      const dateMinute = dateObj.getMinutes();

      const now = new Date();
      const nowYear = now.toLocaleString(locales, { year: 'numeric' });
      const nowMonth = now.toLocaleString(locales, { month: 'numeric' });
      const nowDay = now.toLocaleString(locales, { day: 'numeric' });
      const nowHour = now.getHours();
      const nowMinute = now.getMinutes();

      // set year only if not the same year as now
      if (dateYear !== nowYear) options.year = 'numeric';

      // if today, display relative time
      if (dateYear === nowYear && dateMonth === nowMonth && dateDay === nowDay) {
          const diffHour = nowHour - dateHour;
          const diffMinute = Math.abs(nowMinute - dateMinute);

          if (diffHour === 0 && diffMinute > 30) return '1 h';
          else if (diffHour === 0) return `${diffMinute} min`;
          else if (diffMinute >= 30) return `${diffHour + 1} h`;
          return `${diffHour} h`;
      }

      return dateObj.toLocaleString(locales, options);
  }

    const normalizeMetricPourcent = (metricValue = 0) => Math.round(metricValue * 100);
    const normalizeMetricInSeconds = (metricValue = 1) => (metricValue / 1e3).toFixed(3);
    const normalizeMetricUptime = (metricValue) => humanDate(new Date(metricValue * 1e3));

    const normalizeMetrics = (metric = '', value = 0) => {
      switch (metric){
        case 'event_loop_utilized':
          return normalizeMetricPourcent(value);
        case 'event_loop_delay_milliseconds':
          return normalizeMetricInSeconds(value);
        case 'process_start_time_seconds':
          return normalizeMetricUptime(value);
        default:
          return value;
      }
    }

    class StatusStreamMetricsComponents extends HTMLElement {
        #elem

        constructor() {
            super();

            channel.subscribe(channel.eventType.onError, (e) => this.updateDisplay(e.message));
            channel.subscribe(channel.eventType.onReady, (e) => this.updateDisplay(e.message));

            this.render();
        }

        updateDisplay(value){
          this.#elem.textContent = value;
        }

        render() {
          this.#elem = document.createElement('span');
          this.#elem.textContent = this.getAttribute('text');

          const shadowRoot = this.attachShadow({mode: 'open'});
          shadowRoot.appendChild(this.#elem);
        }
    }

    class MetricsComponents extends HTMLElement {
        #elem

        constructor() {
            super();

            channel.subscribe(channel.eventType.onMessage, (payload) => this.updateDisplay(payload));

            this.render();
        }

        updateDisplay(payload){
          const attrMetrics = this.getAttribute('data-metric') ?? '';

          if(Reflect.has(payload, attrMetrics)) {
            this.#elem.textContent = normalizeMetrics( attrMetrics,payload[attrMetrics]);
          }
        }

        render() {
          this.#elem = document.createElement('span');
          this.#elem.textContent = this.getAttribute('text');

          const shadowRoot = this.attachShadow({mode: 'open'});
          shadowRoot.appendChild(this.#elem);
        }
    }



    const initializeApplication = () => {
//      channel.subscribe(channel.eventType.onMessage, console.log);
      // Register components
      customElements.define('closed-shadow', StatusStreamMetricsComponents);
      customElements.define('metrics-card', MetricsComponents);

      fetchMetricsStream("http://localhost:8080/metrics-stream");
    }

    document.querySelector('html').addEventListener('click', e => {
      console.log(e.composed);
      console.log(e.composedPath());
    });

    initializeApplication();
  </script>
</html>

